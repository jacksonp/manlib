<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>
<refentry>
<refmeta>
<refentrytitle>gitglossary</refentrytitle>
<manvolnum>7</manvolnum>
<refmiscinfo class="source">Git</refmiscinfo>
<refmiscinfo class="manual">Git Manual</refmiscinfo>
</refmeta>
<refnamediv>
  <refname>gitglossary</refname>
  <refpurpose>A Git Glossary</refpurpose>
</refnamediv>
<refsynopsisdiv id="_synopsis">
<simpara>*</simpara>
</refsynopsisdiv>
<refsect1 id="_description">
<title>DESCRIPTION</title>
<variablelist>
<varlistentry>
<term>
<anchor id="def_alternate_object_database" xreflabel="[def_alternate_object_database]"/>alternate object database
</term>
<listitem>
<simpara>
        Via the alternates mechanism, a <link linkend="def_repository">repository</link>
        can inherit part of its <link linkend="def_object_database">object database</link>
        from another object database, which is called "alternate".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_bare_repository" xreflabel="[def_bare_repository]"/>bare repository
</term>
<listitem>
<simpara>
        A bare repository is normally an appropriately
        named <link linkend="def_directory">directory</link> with a <literal>.git</literal> suffix that does not
        have a locally checked-out copy of any of the files under
        revision control. That is, all of the Git
        administrative and control files that would normally be present in the
        hidden <literal>.git</literal> sub-directory are directly present in the
        <literal>repository.git</literal> directory instead,
        and no other files are present and checked out. Usually publishers of
        public repositories make bare repositories available.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_blob_object" xreflabel="[def_blob_object]"/>blob object
</term>
<listitem>
<simpara>
        Untyped <link linkend="def_object">object</link>, e.g. the contents of a file.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_branch" xreflabel="[def_branch]"/>branch
</term>
<listitem>
<simpara>
        A "branch" is an active line of development.  The most recent
        <link linkend="def_commit">commit</link> on a branch is referred to as the tip of
        that branch.  The tip of the branch is referenced by a branch
        <link linkend="def_head">head</link>, which moves forward as additional development
        is done on the branch.  A single Git
        <link linkend="def_repository">repository</link> can track an arbitrary number of
        branches, but your <link linkend="def_working_tree">working tree</link> is
        associated with just one of them (the "current" or "checked out"
        branch), and <link linkend="def_HEAD">HEAD</link> points to that branch.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_cache" xreflabel="[def_cache]"/>cache
</term>
<listitem>
<simpara>
        Obsolete for: <link linkend="def_index">index</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_chain" xreflabel="[def_chain]"/>chain
</term>
<listitem>
<simpara>
        A list of objects, where each <link linkend="def_object">object</link> in the list contains
        a reference to its successor (for example, the successor of a
        <link linkend="def_commit">commit</link> could be one of its <link linkend="def_parent">parents</link>).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_changeset" xreflabel="[def_changeset]"/>changeset
</term>
<listitem>
<simpara>
        BitKeeper/cvsps speak for "<link linkend="def_commit">commit</link>". Since Git does not
        store changes, but states, it really does not make sense to use the term
        "changesets" with Git.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_checkout" xreflabel="[def_checkout]"/>checkout
</term>
<listitem>
<simpara>
        The action of updating all or part of the
        <link linkend="def_working_tree">working tree</link> with a <link linkend="def_tree_object">tree object</link>
        or <link linkend="def_blob_object">blob</link> from the
        <link linkend="def_object_database">object database</link>, and updating the
        <link linkend="def_index">index</link> and <link linkend="def_HEAD">HEAD</link> if the whole working tree has
        been pointed at a new <link linkend="def_branch">branch</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_cherry-picking" xreflabel="[def_cherry-picking]"/>cherry-picking
</term>
<listitem>
<simpara>
        In <link linkend="def_SCM">SCM</link> jargon, "cherry pick" means to choose a subset of
        changes out of a series of changes (typically commits) and record them
        as a new series of changes on top of a different codebase. In Git, this is
        performed by the "git cherry-pick" command to extract the change introduced
        by an existing <link linkend="def_commit">commit</link> and to record it based on the tip
        of the current <link linkend="def_branch">branch</link> as a new commit.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_clean" xreflabel="[def_clean]"/>clean
</term>
<listitem>
<simpara>
        A <link linkend="def_working_tree">working tree</link> is clean, if it
        corresponds to the <link linkend="def_revision">revision</link> referenced by the current
        <link linkend="def_head">head</link>. Also see "<link linkend="def_dirty">dirty</link>".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_commit" xreflabel="[def_commit]"/>commit
</term>
<listitem>
<simpara>
        As a noun: A single point in the
        Git history; the entire history of a project is represented as a
        set of interrelated commits.  The word "commit" is often
        used by Git in the same places other revision control systems
        use the words "revision" or "version".  Also used as a short
        hand for <link linkend="def_commit_object">commit object</link>.
</simpara>
<simpara>As a verb: The action of storing a new snapshot of the project&#8217;s
state in the Git history, by creating a new commit representing the current
state of the <link linkend="def_index">index</link> and advancing <link linkend="def_HEAD">HEAD</link>
to point at the new commit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_commit_object" xreflabel="[def_commit_object]"/>commit object
</term>
<listitem>
<simpara>
        An <link linkend="def_object">object</link> which contains the information about a
        particular <link linkend="def_revision">revision</link>, such as <link linkend="def_parent">parents</link>, committer,
        author, date and the <link linkend="def_tree_object">tree object</link> which corresponds
        to the top <link linkend="def_directory">directory</link> of the stored
        revision.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_commit-ish" xreflabel="[def_commit-ish]"/>commit-ish (also committish)
</term>
<listitem>
<simpara>
        A <link linkend="def_commit_object">commit object</link> or an
        <link linkend="def_object">object</link> that can be recursively dereferenced to
        a commit object.
        The following are all commit-ishes:
        a commit object,
        a <link linkend="def_tag_object">tag object</link> that points to a commit
        object,
        a tag object that points to a tag object that points to a
        commit object,
        etc.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_core_git" xreflabel="[def_core_git]"/>core Git
</term>
<listitem>
<simpara>
        Fundamental data structures and utilities of Git. Exposes only limited
        source code management tools.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_DAG" xreflabel="[def_DAG]"/>DAG
</term>
<listitem>
<simpara>
        Directed acyclic graph. The <link linkend="def_commit_object">commit objects</link> form a
        directed acyclic graph, because they have parents (directed), and the
        graph of commit objects is acyclic (there is no <link linkend="def_chain">chain</link>
        which begins and ends with the same <link linkend="def_object">object</link>).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_dangling_object" xreflabel="[def_dangling_object]"/>dangling object
</term>
<listitem>
<simpara>
        An <link linkend="def_unreachable_object">unreachable object</link> which is not
        <link linkend="def_reachable">reachable</link> even from other unreachable objects; a
        dangling object has no references to it from any
        reference or <link linkend="def_object">object</link> in the <link linkend="def_repository">repository</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_detached_HEAD" xreflabel="[def_detached_HEAD]"/>detached HEAD
</term>
<listitem>
<simpara>
        Normally the <link linkend="def_HEAD">HEAD</link> stores the name of a
        <link linkend="def_branch">branch</link>, and commands that operate on the
        history HEAD represents operate on the history leading to the
        tip of the branch the HEAD points at.  However, Git also
        allows you to <link linkend="def_checkout">check out</link> an arbitrary
        <link linkend="def_commit">commit</link> that isn&#8217;t necessarily the tip of any
        particular branch.  The HEAD in such a state is called
        "detached".
</simpara>
<simpara>Note that commands that operate on the history of the current branch
(e.g. <literal>git commit</literal> to build a new history on top of it) still work
while the HEAD is detached. They update the HEAD to point at the tip
of the updated history without affecting any branch.  Commands that
update or inquire information <emphasis>about</emphasis> the current branch (e.g. <literal>git
branch --set-upstream-to</literal> that sets what remote-tracking branch the
current branch integrates with) obviously do not work, as there is no
(real) current branch to ask about in this state.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_directory" xreflabel="[def_directory]"/>directory
</term>
<listitem>
<simpara>
        The list you get with "ls" :-)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_dirty" xreflabel="[def_dirty]"/>dirty
</term>
<listitem>
<simpara>
        A <link linkend="def_working_tree">working tree</link> is said to be "dirty" if
        it contains modifications which have not been <link linkend="def_commit">committed</link> to the current
        <link linkend="def_branch">branch</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_evil_merge" xreflabel="[def_evil_merge]"/>evil merge
</term>
<listitem>
<simpara>
        An evil merge is a <link linkend="def_merge">merge</link> that introduces changes that
        do not appear in any <link linkend="def_parent">parent</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_fast_forward" xreflabel="[def_fast_forward]"/>fast-forward
</term>
<listitem>
<simpara>
        A fast-forward is a special type of <link linkend="def_merge">merge</link> where you have a
        <link linkend="def_revision">revision</link> and you are "merging" another
        <link linkend="def_branch">branch</link>'s changes that happen to be a descendant of what
        you have. In such these cases, you do not make a new <link linkend="def_merge">merge</link>
        <link linkend="def_commit">commit</link> but instead just update to his
        revision. This will happen frequently on a
        <link linkend="def_remote_tracking_branch">remote-tracking branch</link> of a remote
        <link linkend="def_repository">repository</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_fetch" xreflabel="[def_fetch]"/>fetch
</term>
<listitem>
<simpara>
        Fetching a <link linkend="def_branch">branch</link> means to get the
        branch&#8217;s <link linkend="def_head_ref">head ref</link> from a remote
        <link linkend="def_repository">repository</link>, to find out which objects are
        missing from the local <link linkend="def_object_database">object database</link>,
        and to get them, too.  See also <citerefentry>
<refentrytitle>git-fetch</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_file_system" xreflabel="[def_file_system]"/>file system
</term>
<listitem>
<simpara>
        Linus Torvalds originally designed Git to be a user space file system,
        i.e. the infrastructure to hold files and directories. That ensured the
        efficiency and speed of Git.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_git_archive" xreflabel="[def_git_archive]"/>Git archive
</term>
<listitem>
<simpara>
        Synonym for <link linkend="def_repository">repository</link> (for arch people).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_gitfile" xreflabel="[def_gitfile]"/>gitfile
</term>
<listitem>
<simpara>
        A plain file <literal>.git</literal> at the root of a working tree that
        points at the directory that is the real repository.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_grafts" xreflabel="[def_grafts]"/>grafts
</term>
<listitem>
<simpara>
        Grafts enables two otherwise different lines of development to be joined
        together by recording fake ancestry information for commits. This way
        you can make Git pretend the set of <link linkend="def_parent">parents</link> a <link linkend="def_commit">commit</link> has
        is different from what was recorded when the commit was
        created. Configured via the <literal>.git/info/grafts</literal> file.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_hash" xreflabel="[def_hash]"/>hash
</term>
<listitem>
<simpara>
        In Git&#8217;s context, synonym for <link linkend="def_object_name">object name</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_head" xreflabel="[def_head]"/>head
</term>
<listitem>
<simpara>
        A <link linkend="def_ref">named reference</link> to the <link linkend="def_commit">commit</link> at the tip of a
        <link linkend="def_branch">branch</link>.  Heads are stored in a file in
        <literal>$GIT_DIR/refs/heads/</literal> directory, except when using packed refs. (See
        <citerefentry>
<refentrytitle>git-pack-refs</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>.)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_HEAD" xreflabel="[def_HEAD]"/>HEAD
</term>
<listitem>
<simpara>
        The current <link linkend="def_branch">branch</link>.  In more detail: Your <link linkend="def_working_tree">working tree</link> is normally derived from the state of the tree
        referred to by HEAD.  HEAD is a reference to one of the
        <link linkend="def_head">heads</link> in your repository, except when using a
        <link linkend="def_detached_HEAD">detached HEAD</link>, in which case it directly
        references an arbitrary commit.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_head_ref" xreflabel="[def_head_ref]"/>head ref
</term>
<listitem>
<simpara>
        A synonym for <link linkend="def_head">head</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_hook" xreflabel="[def_hook]"/>hook
</term>
<listitem>
<simpara>
        During the normal execution of several Git commands, call-outs are made
        to optional scripts that allow a developer to add functionality or
        checking. Typically, the hooks allow for a command to be pre-verified
        and potentially aborted, and allow for a post-notification after the
        operation is done. The hook scripts are found in the
        <literal>$GIT_DIR/hooks/</literal> directory, and are enabled by simply
        removing the <literal>.sample</literal> suffix from the filename. In earlier versions
        of Git you had to make them executable.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_index" xreflabel="[def_index]"/>index
</term>
<listitem>
<simpara>
        A collection of files with stat information, whose contents are stored
        as objects. The index is a stored version of your
        <link linkend="def_working_tree">working tree</link>. Truth be told, it can also contain a second, and even
        a third version of a working tree, which are used
        when <link linkend="def_merge">merging</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_index_entry" xreflabel="[def_index_entry]"/>index entry
</term>
<listitem>
<simpara>
        The information regarding a particular file, stored in the
        <link linkend="def_index">index</link>. An index entry can be unmerged, if a
        <link linkend="def_merge">merge</link> was started, but not yet finished (i.e. if
        the index contains multiple versions of that file).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_master" xreflabel="[def_master]"/>master
</term>
<listitem>
<simpara>
        The default development <link linkend="def_branch">branch</link>. Whenever you
        create a Git <link linkend="def_repository">repository</link>, a branch named
        "master" is created, and becomes the active branch. In most
        cases, this contains the local development, though that is
        purely by convention and is not required.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_merge" xreflabel="[def_merge]"/>merge
</term>
<listitem>
<simpara>
        As a verb: To bring the contents of another
        <link linkend="def_branch">branch</link> (possibly from an external
        <link linkend="def_repository">repository</link>) into the current branch.  In the
        case where the merged-in branch is from a different repository,
        this is done by first <link linkend="def_fetch">fetching</link> the remote branch
        and then merging the result into the current branch.  This
        combination of fetch and merge operations is called a
        <link linkend="def_pull">pull</link>.  Merging is performed by an automatic process
        that identifies changes made since the branches diverged, and
        then applies all those changes together.  In cases where changes
        conflict, manual intervention may be required to complete the
        merge.
</simpara>
<simpara>As a noun: unless it is a <link linkend="def_fast_forward">fast-forward</link>, a
successful merge results in the creation of a new <link linkend="def_commit">commit</link>
representing the result of the merge, and having as
<link linkend="def_parent">parents</link> the tips of the merged <link linkend="def_branch">branches</link>.
This commit is referred to as a "merge commit", or sometimes just a
"merge".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_object" xreflabel="[def_object]"/>object
</term>
<listitem>
<simpara>
        The unit of storage in Git. It is uniquely identified by the
        <link linkend="def_SHA1">SHA-1</link> of its contents. Consequently, an
        object can not be changed.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_object_database" xreflabel="[def_object_database]"/>object database
</term>
<listitem>
<simpara>
        Stores a set of "objects", and an individual <link linkend="def_object">object</link> is
        identified by its <link linkend="def_object_name">object name</link>. The objects usually
        live in <literal>$GIT_DIR/objects/</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_object_identifier" xreflabel="[def_object_identifier]"/>object identifier
</term>
<listitem>
<simpara>
        Synonym for <link linkend="def_object_name">object name</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_object_name" xreflabel="[def_object_name]"/>object name
</term>
<listitem>
<simpara>
        The unique identifier of an <link linkend="def_object">object</link>.  The
        object name is usually represented by a 40 character
        hexadecimal string.  Also colloquially called <link linkend="def_SHA1">SHA-1</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_object_type" xreflabel="[def_object_type]"/>object type
</term>
<listitem>
<simpara>
        One of the identifiers "<link linkend="def_commit_object">commit</link>",
        "<link linkend="def_tree_object">tree</link>", "<link linkend="def_tag_object">tag</link>" or
        "<link linkend="def_blob_object">blob</link>" describing the type of an
        <link linkend="def_object">object</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_octopus" xreflabel="[def_octopus]"/>octopus
</term>
<listitem>
<simpara>
        To <link linkend="def_merge">merge</link> more than two <link linkend="def_branch">branches</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_origin" xreflabel="[def_origin]"/>origin
</term>
<listitem>
<simpara>
        The default upstream <link linkend="def_repository">repository</link>. Most projects have
        at least one upstream project which they track. By default
        <emphasis>origin</emphasis> is used for that purpose. New upstream updates
        will be fetched into <link linkend="def_remote_tracking_branch">remote-tracking branches</link> named
        origin/name-of-upstream-branch, which you can see using
        <literal>git branch -r</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_pack" xreflabel="[def_pack]"/>pack
</term>
<listitem>
<simpara>
        A set of objects which have been compressed into one file (to save space
        or to transmit them efficiently).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_pack_index" xreflabel="[def_pack_index]"/>pack index
</term>
<listitem>
<simpara>
        The list of identifiers, and other information, of the objects in a
        <link linkend="def_pack">pack</link>, to assist in efficiently accessing the contents of a
        pack.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_pathspec" xreflabel="[def_pathspec]"/>pathspec
</term>
<listitem>
<simpara>
        Pattern used to limit paths in Git commands.
</simpara>
<simpara>Pathspecs are used on the command line of "git ls-files", "git
ls-tree", "git add", "git grep", "git diff", "git checkout",
and many other commands to
limit the scope of operations to some subset of the tree or
worktree.  See the documentation of each command for whether
paths are relative to the current directory or toplevel.  The
pathspec syntax is as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>
any path matches itself
</simpara>
</listitem>
<listitem>
<simpara>
the pathspec up to the last slash represents a
  directory prefix.  The scope of that pathspec is
  limited to that subtree.
</simpara>
</listitem>
<listitem>
<simpara>
the rest of the pathspec is a pattern for the remainder
  of the pathname.  Paths relative to the directory
  prefix will be matched against that pattern using fnmatch(3);
  in particular, <emphasis>*</emphasis> and <emphasis>?</emphasis> <emphasis>can</emphasis> match directory separators.
</simpara>
</listitem>
</itemizedlist>
<simpara>For example, Documentation/*.jpg will match all .jpg files
in the Documentation subtree,
including Documentation/chapter_1/figure_1.jpg.</simpara>
<simpara>A pathspec that begins with a colon <literal>:</literal> has special meaning.  In the
short form, the leading colon <literal>:</literal> is followed by zero or more "magic
signature" letters (which optionally is terminated by another colon <literal>:</literal>),
and the remainder is the pattern to match against the path.
The "magic signature" consists of ASCII symbols that are neither
alphanumeric, glob, regex special charaters nor colon.
The optional colon that terminates the "magic signature" can be
omitted if the pattern begins with a character that does not belong to
"magic signature" symbol set and is not a colon.</simpara>
<simpara>In the long form, the leading colon <literal>:</literal> is followed by a open
parenthesis <literal>(</literal>, a comma-separated list of zero or more "magic words",
and a close parentheses <literal>)</literal>, and the remainder is the pattern to match
against the path.</simpara>
<simpara>A pathspec with only a colon means "there is no pathspec". This form
should not be combined with other pathspec.</simpara>
<variablelist>
<varlistentry>
<term>
top
</term>
<listitem>
<simpara>
        The magic word <literal>top</literal> (magic signature: <literal>/</literal>) makes the pattern
        match from the root of the working tree, even when you are
        running the command from inside a subdirectory.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
literal
</term>
<listitem>
<simpara>
        Wildcards in the pattern such as <literal>*</literal> or <literal>?</literal> are treated
        as literal characters.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
icase
</term>
<listitem>
<simpara>
        Case insensitive match.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
glob
</term>
<listitem>
<simpara>
        Git treats the pattern as a shell glob suitable for
        consumption by fnmatch(3) with the FNM_PATHNAME flag:
        wildcards in the pattern will not match a / in the pathname.
        For example, "Documentation/&#42;.html" matches
        "Documentation/git.html" but not "Documentation/ppc/ppc.html"
        or "tools/perf/Documentation/perf.html".
</simpara>
<simpara>Two consecutive asterisks ("<literal>**</literal>") in patterns matched against
full pathname may have special meaning:</simpara>
<itemizedlist>
<listitem>
<simpara>
A leading "<literal>**</literal>" followed by a slash means match in all
   directories. For example, "<literal>**/foo</literal>" matches file or directory
   "<literal>foo</literal>" anywhere, the same as pattern "<literal>foo</literal>". "<literal>**/foo/bar</literal>"
   matches file or directory "<literal>bar</literal>" anywhere that is directly
   under directory "<literal>foo</literal>".
</simpara>
</listitem>
<listitem>
<simpara>
A trailing "<literal>/**</literal>" matches everything inside. For example,
   "<literal>abc/**</literal>" matches all files inside directory "abc", relative
   to the location of the <literal>.gitignore</literal> file, with infinite depth.
</simpara>
</listitem>
<listitem>
<simpara>
A slash followed by two consecutive asterisks then a slash
   matches zero or more directories. For example, "<literal>a/**/b</literal>"
   matches "<literal>a/b</literal>", "<literal>a/x/b</literal>", "<literal>a/x/y/b</literal>" and so on.
</simpara>
</listitem>
<listitem>
<simpara>
Other consecutive asterisks are considered invalid.
</simpara>
<simpara>Glob magic is incompatible with literal magic.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
exclude
</term>
<listitem>
<simpara>
        After a path matches any non-exclude pathspec, it will be run
        through all exclude pathspec (magic signature: <literal>!</literal>). If it
        matches, the path is ignored.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_parent" xreflabel="[def_parent]"/>parent
</term>
<listitem>
<simpara>
        A <link linkend="def_commit_object">commit object</link> contains a (possibly empty) list
        of the logical predecessor(s) in the line of development, i.e. its
        parents.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_pickaxe" xreflabel="[def_pickaxe]"/>pickaxe
</term>
<listitem>
<simpara>
        The term <link linkend="def_pickaxe">pickaxe</link> refers to an option to the diffcore
        routines that help select changes that add or delete a given text
        string. With the <literal>--pickaxe-all</literal> option, it can be used to view the full
        <link linkend="def_changeset">changeset</link> that introduced or removed, say, a
        particular line of text. See <citerefentry>
<refentrytitle>git-diff</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_plumbing" xreflabel="[def_plumbing]"/>plumbing
</term>
<listitem>
<simpara>
        Cute name for <link linkend="def_core_git">core Git</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_porcelain" xreflabel="[def_porcelain]"/>porcelain
</term>
<listitem>
<simpara>
        Cute name for programs and program suites depending on
        <link linkend="def_core_git">core Git</link>, presenting a high level access to
        core Git. Porcelains expose more of a <link linkend="def_SCM">SCM</link>
        interface than the <link linkend="def_plumbing">plumbing</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_pull" xreflabel="[def_pull]"/>pull
</term>
<listitem>
<simpara>
        Pulling a <link linkend="def_branch">branch</link> means to <link linkend="def_fetch">fetch</link> it and
        <link linkend="def_merge">merge</link> it.  See also <citerefentry>
<refentrytitle>git-pull</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_push" xreflabel="[def_push]"/>push
</term>
<listitem>
<simpara>
        Pushing a <link linkend="def_branch">branch</link> means to get the branch&#8217;s
        <link linkend="def_head_ref">head ref</link> from a remote <link linkend="def_repository">repository</link>,
        find out if it is a direct ancestor to the branch&#8217;s local
        head ref, and in that case, putting all
        objects, which are <link linkend="def_reachable">reachable</link> from the local
        head ref, and which are missing from the remote
        repository, into the remote
        <link linkend="def_object_database">object database</link>, and updating the remote
        head ref. If the remote <link linkend="def_head">head</link> is not an
        ancestor to the local head, the push fails.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_reachable" xreflabel="[def_reachable]"/>reachable
</term>
<listitem>
<simpara>
        All of the ancestors of a given <link linkend="def_commit">commit</link> are said to be
        "reachable" from that commit. More
        generally, one <link linkend="def_object">object</link> is reachable from
        another if we can reach the one from the other by a <link linkend="def_chain">chain</link>
        that follows <link linkend="def_tag">tags</link> to whatever they tag,
        <link linkend="def_commit_object">commits</link> to their parents or trees, and
        <link linkend="def_tree_object">trees</link> to the trees or <link linkend="def_blob_object">blobs</link>
        that they contain.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_rebase" xreflabel="[def_rebase]"/>rebase
</term>
<listitem>
<simpara>
        To reapply a series of changes from a <link linkend="def_branch">branch</link> to a
        different base, and reset the <link linkend="def_head">head</link> of that branch
        to the result.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_ref" xreflabel="[def_ref]"/>ref
</term>
<listitem>
<simpara>
        A name that begins with <literal>refs/</literal> (e.g. <literal>refs/heads/master</literal>)
        that points to an <link linkend="def_object_name">object name</link> or another
        ref (the latter is called a <link linkend="def_symref">symbolic ref</link>).
        For convenience, a ref can sometimes be abbreviated when used
        as an argument to a Git command; see <citerefentry>
<refentrytitle>gitrevisions</refentrytitle><manvolnum>7</manvolnum>
</citerefentry>
        for details.
        Refs are stored in the <link linkend="def_repository">repository</link>.
</simpara>
<simpara>The ref namespace is hierarchical.
Different subhierarchies are used for different purposes (e.g. the
<literal>refs/heads/</literal> hierarchy is used to represent local branches).</simpara>
<simpara>There are a few special-purpose refs that do not begin with <literal>refs/</literal>.
The most notable example is <literal>HEAD</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_reflog" xreflabel="[def_reflog]"/>reflog
</term>
<listitem>
<simpara>
        A reflog shows the local "history" of a ref.  In other words,
        it can tell you what the 3rd last revision in <emphasis>this</emphasis> repository
        was, and what was the current state in <emphasis>this</emphasis> repository,
        yesterday 9:14pm.  See <citerefentry>
<refentrytitle>git-reflog</refentrytitle><manvolnum>1</manvolnum>
</citerefentry> for details.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_refspec" xreflabel="[def_refspec]"/>refspec
</term>
<listitem>
<simpara>
        A "refspec" is used by <link linkend="def_fetch">fetch</link> and
        <link linkend="def_push">push</link> to describe the mapping between remote
        <link linkend="def_ref">ref</link> and local ref.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_remote_tracking_branch" xreflabel="[def_remote_tracking_branch]"/>remote-tracking branch
</term>
<listitem>
<simpara>
        A <link linkend="def_ref">ref</link> that is used to follow changes from another
        <link linkend="def_repository">repository</link>. It typically looks like
        <emphasis>refs/remotes/foo/bar</emphasis> (indicating that it tracks a branch named
        <emphasis>bar</emphasis> in a remote named <emphasis>foo</emphasis>), and matches the right-hand-side of
        a configured fetch <link linkend="def_refspec">refspec</link>. A remote-tracking
        branch should not contain direct modifications or have local
        commits made to it.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_repository" xreflabel="[def_repository]"/>repository
</term>
<listitem>
<simpara>
        A collection of <link linkend="def_ref">refs</link> together with an
        <link linkend="def_object_database">object database</link> containing all objects
        which are <link linkend="def_reachable">reachable</link> from the refs, possibly
        accompanied by meta data from one or more <link linkend="def_porcelain">porcelains</link>. A
        repository can share an object database with other repositories
        via <link linkend="def_alternate_object_database">alternates mechanism</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_resolve" xreflabel="[def_resolve]"/>resolve
</term>
<listitem>
<simpara>
        The action of fixing up manually what a failed automatic
        <link linkend="def_merge">merge</link> left behind.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_revision" xreflabel="[def_revision]"/>revision
</term>
<listitem>
<simpara>
        Synonym for <link linkend="def_commit">commit</link> (the noun).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_rewind" xreflabel="[def_rewind]"/>rewind
</term>
<listitem>
<simpara>
        To throw away part of the development, i.e. to assign the
        <link linkend="def_head">head</link> to an earlier <link linkend="def_revision">revision</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_SCM" xreflabel="[def_SCM]"/>SCM
</term>
<listitem>
<simpara>
        Source code management (tool).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_SHA1" xreflabel="[def_SHA1]"/>SHA-1
</term>
<listitem>
<simpara>
        "Secure Hash Algorithm 1"; a cryptographic hash function.
        In the context of Git used as a synonym for <link linkend="def_object_name">object name</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_shallow_repository" xreflabel="[def_shallow_repository]"/>shallow repository
</term>
<listitem>
<simpara>
        A shallow <link linkend="def_repository">repository</link> has an incomplete
        history some of whose <link linkend="def_commit">commits</link> have <link linkend="def_parent">parents</link> cauterized away (in other
        words, Git is told to pretend that these commits do not have the
        parents, even though they are recorded in the <link linkend="def_commit_object">commit         object</link>). This is sometimes useful when you are interested only in the
        recent history of a project even though the real history recorded in the
        upstream is much larger. A shallow repository
        is created by giving the <literal>--depth</literal> option to <citerefentry>
<refentrytitle>git-clone</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>, and
        its history can be later deepened with <citerefentry>
<refentrytitle>git-fetch</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_symref" xreflabel="[def_symref]"/>symref
</term>
<listitem>
<simpara>
        Symbolic reference: instead of containing the <link linkend="def_SHA1">SHA-1</link>
        id itself, it is of the format <emphasis>ref: refs/some/thing</emphasis> and when
        referenced, it recursively dereferences to this reference.
        <emphasis><link linkend="def_HEAD">HEAD</link></emphasis> is a prime example of a symref. Symbolic
        references are manipulated with the <citerefentry>
<refentrytitle>git-symbolic-ref</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>
        command.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_tag" xreflabel="[def_tag]"/>tag
</term>
<listitem>
<simpara>
        A <link linkend="def_ref">ref</link> under <literal>refs/tags/</literal> namespace that points to an
        object of an arbitrary type (typically a tag points to either a
        <link linkend="def_tag_object">tag</link> or a <link linkend="def_commit_object">commit object</link>).
        In contrast to a <link linkend="def_head">head</link>, a tag is not updated by
        the <literal>commit</literal> command. A Git tag has nothing to do with a Lisp
        tag (which would be called an <link linkend="def_object_type">object type</link>
        in Git&#8217;s context). A tag is most typically used to mark a particular
        point in the commit ancestry <link linkend="def_chain">chain</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_tag_object" xreflabel="[def_tag_object]"/>tag object
</term>
<listitem>
<simpara>
        An <link linkend="def_object">object</link> containing a <link linkend="def_ref">ref</link> pointing to
        another object, which can contain a message just like a
        <link linkend="def_commit_object">commit object</link>. It can also contain a (PGP)
        signature, in which case it is called a "signed tag object".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_topic_branch" xreflabel="[def_topic_branch]"/>topic branch
</term>
<listitem>
<simpara>
        A regular Git <link linkend="def_branch">branch</link> that is used by a developer to
        identify a conceptual line of development. Since branches are very easy
        and inexpensive, it is often desirable to have several small branches
        that each contain very well defined concepts or small incremental yet
        related changes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_tree" xreflabel="[def_tree]"/>tree
</term>
<listitem>
<simpara>
        Either a <link linkend="def_working_tree">working tree</link>, or a <link linkend="def_tree_object">tree         object</link> together with the dependent <link linkend="def_blob_object">blob</link> and tree objects
        (i.e. a stored representation of a working tree).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_tree_object" xreflabel="[def_tree_object]"/>tree object
</term>
<listitem>
<simpara>
        An <link linkend="def_object">object</link> containing a list of file names and modes along
        with refs to the associated blob and/or tree objects. A
        <link linkend="def_tree">tree</link> is equivalent to a <link linkend="def_directory">directory</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_tree-ish" xreflabel="[def_tree-ish]"/>tree-ish (also treeish)
</term>
<listitem>
<simpara>
        A <link linkend="def_tree_object">tree object</link> or an <link linkend="def_object">object</link>
        that can be recursively dereferenced to a tree object.
        Dereferencing a <link linkend="def_commit_object">commit object</link> yields the
        tree object corresponding to the <link linkend="def_revision">revision</link>'s
        top <link linkend="def_directory">directory</link>.
        The following are all tree-ishes:
        a <link linkend="def_commit-ish">commit-ish</link>,
        a tree object,
        a <link linkend="def_tag_object">tag object</link> that points to a tree object,
        a tag object that points to a tag object that points to a tree
        object,
        etc.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_unmerged_index" xreflabel="[def_unmerged_index]"/>unmerged index
</term>
<listitem>
<simpara>
        An <link linkend="def_index">index</link> which contains unmerged
        <link linkend="def_index_entry">index entries</link>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_unreachable_object" xreflabel="[def_unreachable_object]"/>unreachable object
</term>
<listitem>
<simpara>
        An <link linkend="def_object">object</link> which is not <link linkend="def_reachable">reachable</link> from a
        <link linkend="def_branch">branch</link>, <link linkend="def_tag">tag</link>, or any other reference.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_upstream_branch" xreflabel="[def_upstream_branch]"/>upstream branch
</term>
<listitem>
<simpara>
        The default <link linkend="def_branch">branch</link> that is merged into the branch in
        question (or the branch in question is rebased onto). It is configured
        via branch.&lt;name&gt;.remote and branch.&lt;name&gt;.merge. If the upstream branch
        of <emphasis>A</emphasis> is <emphasis>origin/B</emphasis> sometimes we say "<emphasis>A</emphasis> is tracking <emphasis>origin/B</emphasis>".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<anchor id="def_working_tree" xreflabel="[def_working_tree]"/>working tree
</term>
<listitem>
<simpara>
        The tree of actual checked out files.  The working tree normally
        contains the contents of the <link linkend="def_HEAD">HEAD</link> commit&#8217;s tree,
        plus any local changes that you have made but not yet committed.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</refsect1>
<refsect1 id="_see_also">
<title>SEE ALSO</title>
<simpara><citerefentry>
<refentrytitle>gittutorial</refentrytitle><manvolnum>7</manvolnum>
</citerefentry>,
<citerefentry>
<refentrytitle>gittutorial-2</refentrytitle><manvolnum>7</manvolnum>
</citerefentry>,
<citerefentry>
<refentrytitle>gitcvs-migration</refentrytitle><manvolnum>7</manvolnum>
</citerefentry>,
<ulink url="everyday.html">Everyday Git</ulink>,
<ulink url="user-manual.html">The Git User&#8217;s Manual</ulink></simpara>
</refsect1>
<refsect1 id="_git">
<title>GIT</title>
<simpara>Part of the <citerefentry>
<refentrytitle>git</refentrytitle><manvolnum>1</manvolnum>
</citerefentry> suite.</simpara>
</refsect1>
</refentry>
