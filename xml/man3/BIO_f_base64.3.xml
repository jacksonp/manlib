<!-- Converted by db4-upgrade version 1.1 -->
<refentry xmlns="http://docbook.org/ns/docbook" version="5.0">
  <refmeta>
    <refentrytitle>BIO_f_base64.pod</refentrytitle>
  </refmeta>
  <refnamediv>
    <refname>BIO_f_base64</refname>
<refpurpose>base64 BIO filter</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
<synopsis format="linespecific">#include &lt;openssl/bio.h&gt;
#include &lt;openssl/evp.h&gt;</synopsis>
<synopsis format="linespecific">BIO_METHOD *   BIO_f_base64(void);</synopsis>
  </refsynopsisdiv>
  <refsection xml:id="sources.openssl.doc.crypto.BIO_f_base64.pod:DESCRIPTION"><title>DESCRIPTION</title>
    <para>
      BIO_f_base64() returns the base64 BIO method. This is a filter BIO
      that base64 encodes any data written through it and decodes any data
      read through it.
    </para>
    <para>
      Base64 BIOs do not support BIO_gets() or BIO_puts().
    </para>
    <para>
      BIO_flush() on a base64 BIO that is being written through is used to
      signal that no more data is to be encoded: this is used to flush the
      final block through the BIO.
    </para>
    <para>
      The flag BIO_FLAGS_BASE64_NO_NL can be set with BIO_set_flags() to
      encode the data all on one line or expect the data to be all on one
      line.
    </para>
  </refsection>
  <refsection xml:id="sources.openssl.doc.crypto.BIO_f_base64.pod:NOTES"><title>NOTES</title>
    <para>
      Because of the format of base64 encoding the end of the encoded block
      cannot always be reliably determined.
    </para>
  </refsection>
  <refsection xml:id="sources.openssl.doc.crypto.BIO_f_base64.pod:RETURN_VALUES"><title>RETURN VALUES</title>
    <para>
      BIO_f_base64() returns the base64 BIO method.
    </para>
  </refsection>
  <refsection xml:id="sources.openssl.doc.crypto.BIO_f_base64.pod:EXAMPLES"><title>EXAMPLES</title>
    <para>
      Base64 encode the string "Hello World\n" and write the result to
      standard output:
    </para>
    <screen>BIO *bio, *b64;
char message[] = "Hello World \n";

b64 = BIO_new(BIO_f_base64());
bio = BIO_new_fp(stdout, BIO_NOCLOSE);
bio = BIO_push(b64, bio);
BIO_write(bio, message, strlen(message));
BIO_flush(bio);

BIO_free_all(bio);</screen>
    <para>
      Read Base64 encoded data from standard input and write the decoded
      data to standard output:
    </para>
    <screen>BIO *bio, *b64, *bio_out;
char inbuf[512];
int inlen;

b64 = BIO_new(BIO_f_base64());
bio = BIO_new_fp(stdin, BIO_NOCLOSE);
bio_out = BIO_new_fp(stdout, BIO_NOCLOSE);
bio = BIO_push(b64, bio);
while((inlen = BIO_read(bio, inbuf, 512)) &gt; 0) 
       BIO_write(bio_out, inbuf, inlen);

BIO_free_all(bio);</screen>
  </refsection>
  <refsection xml:id="sources.openssl.doc.crypto.BIO_f_base64.pod:BUGS"><title>BUGS</title>
    <para>
      The ambiguity of EOF in base64 encoded data can cause additional data
      following the base64 encoded block to be misinterpreted.
    </para>
    <para>
      There should be some way of specifying a test that the BIO can
      perform to reliably determine EOF (for example a MIME boundary).
    </para>
  </refsection>
  <refsection xml:id="sources.openssl.doc.crypto.BIO_f_base64.pod:SEE_ALSO"><title>SEE ALSO</title>
    <para>
      TBA
    </para>
  </refsection>
</refentry>