<!-- Converted by db4-upgrade version 1.1 -->
<refentry xmlns="http://docbook.org/ns/docbook" version="5.0">
  <refmeta>
    <refentrytitle>CRYPTO_secure_malloc.pod</refentrytitle>
  </refmeta>
  <refnamediv>
    <refname>CRYPTO_secure_malloc_init, CRYPTO_secure_malloc_done, OPENSSL_secure_malloc, OPENSSL_secure_free, OPENSSL_secure_allocated</refname>
<refpurpose>use secure heap storage</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
<synopsis>#include &lt;openssl/crypto.h&gt;</synopsis>
<synopsis>int CRYPTO_secure_malloc_init(size_t size, int minsize);</synopsis>
<synopsis>int CRYPTO_secure_malloc_initialized();</synopsis>
<synopsis>void CRYPTO_secure_malloc_done();</synopsis>
<synopsis>void *OPENSSL_secure_malloc(int num);</synopsis>
<synopsis>void OPENSSL_secure_free(void* ptr);</synopsis>
<synopsis>int OPENSSL_secure_allocated(const void* ptr);</synopsis>
  </refsynopsisdiv>
  <refsection xml:id="ID-acc0f5d56c3bb5d275e05facac50fb35"><title>DESCRIPTION</title>
    <para>
      In order to help protect applications (particularly long-running
      servers) from pointer overruns or underruns that could return
      arbitrary data from the program's dynamic memory area, where keys and
      other sensitive information might be stored, OpenSSL supports the
      concept of a "secure heap." The level and type of security guarantees
      depend on the operating system. It is a good idea to review the code
      and see if it addresses your threat model and concerns.
    </para>
    <para>
      If a secure heap is used, then private key <emphasis role="bold">BIGNUM</emphasis> values are stored there. This protects
      long-term storage of private keys, but will not necessarily put all
      intermediate values and computations there.
    </para>
    <para>
      <emphasis role="bold">CRYPTO_secure_malloc_init</emphasis> creates
      the secure heap, with the specified <literal role="code">size</literal> in bytes. The <literal role="code">minsize</literal> parameter is the minimum
      size to allocate from the heap. Both <literal role="code">size</literal> and <literal role="code">minsize</literal> must be a power of two.  It
      is an error to call this after any <emphasis role="bold">OPENSSL_secure_malloc</emphasis> calls have been made.
    </para>
    <para>
      <emphasis role="bold">CRYPTO_secure_malloc_initialized</emphasis>
      indicates whether or not the secure heap as been initialized and is
      available.
    </para>
    <para>
      <emphasis role="bold">CRYPTO_secure_malloc_done</emphasis> releases
      the heap and makes the memory unavailable to the process. It can take
      noticeably long to complete.
    </para>
    <para>
      <emphasis role="bold">OPENSSL_secure_malloc</emphasis> allocates
      <literal role="code">num</literal> bytes from the heap.
      If <emphasis role="bold">CRYPTO_secure_malloc_init</emphasis> is not
      called, this is equivalent to calling <emphasis role="bold">OPENSSL_malloc</emphasis>.
    </para>
    <para>
      <emphasis role="bold">OPENSSL_secure_free</emphasis> releases the
      memory at <literal role="code">ptr</literal> back to the
      heap. It must be called with a value previously obtained from
      <emphasis role="bold">OPENSSL_secure_malloc</emphasis>. If <emphasis role="bold">CRYPTO_secure_malloc_init</emphasis> is not called, this
      is equivalent to calling <emphasis role="bold">OPENSSL_free</emphasis>.
    </para>
    <para>
      <emphasis role="bold">OPENSSL_secure_allocated</emphasis> tells
      whether or not a pointer is within the secure heap.
    </para>
  </refsection>
  <refsection xml:id="ID-d6450b1a462e78c26de11735881015b6"><title>RETURN VALUES</title>
    <para>
      <emphasis role="bold">CRYPTO_secure_malloc_init</emphasis> returns 0
      on failure, 1 if successful, and 2 if successful but the heap could
      not be protected by memory mapping.
    </para>
    <para>
      <emphasis role="bold">CRYPTO_secure_malloc_initialized</emphasis>
      returns 1 if the secure heap is available (that is, if <emphasis role="bold">CRYPTO_secure_malloc_init</emphasis> has been called, but
      <emphasis role="bold">CRYPTO_secure_malloc_done</emphasis> has not)
      or 0 if not.
    </para>
    <para>
      <emphasis role="bold">OPENSSL_secure_malloc</emphasis> returns a
      pointer into the secure heap of the requested size, or <literal role="code">NULL</literal> if memory could not be
      allocated.
    </para>
    <para>
      <emphasis role="bold">CRYPTO_secure_allocated</emphasis> returns 1 if
      the pointer is in the the secure heap, or 0 if not.
    </para>
    <para>
      <emphasis role="bold">CRYPTO_secure_malloc_done</emphasis> and
      <emphasis role="bold">OPENSSL_secure_free</emphasis> return no
      values.
    </para>
  </refsection>
  <refsection xml:id="ID-29fc724a2dd6cffbb7dca81004473c23"><title>SEE ALSO</title>
    <para>
      <citerefentry> <refentrytitle>BN_new</refentrytitle>
      <manvolnum>3</manvolnum> </citerefentry>, <citerefentry>
      <refentrytitle>bn_internal</refentrytitle> <manvolnum>3</manvolnum>
      </citerefentry>
    </para>
  </refsection>
  <refsection xml:id="ID-382e1c6493575a8075a5e616249af658"><title>HISTORY</title>
    <para>
      These functions were contributed to the OpenSSL project by Akamai
      Technologies in April, 2014.
    </para>
  </refsection>
</refentry>